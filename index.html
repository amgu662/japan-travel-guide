<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="theme-color" content="#C41E3A">
    <title>××•×¨×” ×“×¨×š ×™×¤×Ÿ - ×”××“×¨×™×š ×”××™×©×™ ×©×œ×š</title>
    
    <!-- PWA Meta Tags -->
    <link rel="manifest" href="data:application/json;base64,eyJuYW1lIjoi15XXqNWUINeT16jXmiDXmdek158gLSDXlded16jXmdeZINeU15DXmdep15kg16nXnNWaIiwic2hvcnRfbmFtZSI6IteV15XXqNWUINeT16jXmiDXmdek158iLCJkZXNjcmlwdGlvbiI6Iteexdem16jXmdWaINeY15nXldec15nedSDXl9eZ150g15zXmdek158g16LedSDXltef15nXldeVINeq157Xldeg15XXqiDXldeR16LXkdeo15nXqiIsInN0YXJ0X3VybCI6Ii8iLCJkaXNwbGF5Ijoic3RhbmRhbG9uZSIsImJhY2tncm91bmRfY29sb3IiOiIjRThGNEY4IiwidGhlbWVfY29sb3IiOiIjQzQxRTNBIiwib3JpZW50YXRpb24iOiJwb3J0cmFpdCIsImRpciI6InJ0bCIsImxhbmciOiJoZSIsImljb25zIjpbeyJzcmMiOiJkYXRhOmltYWdlL3N2Zyt4bWwsJTNDc3ZnIHhtbG5zPSdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Zycgdmlld0JveD0nMCAwIDEwMCAxMDAnJTNFJTNDY2lyY2xlIGN4PSc1MCcgY3k9JzUwJyByPSc1MCcgZmlsbD0nJTIzQzQxRTNBJy8lM0UlM0N0ZXh0IHg9JzUwJyB5PSc3MCcgZm9udC1zaXplPSc2MCcgdGV4dC1hbmNob3I9J21pZGRsZScgZmlsbD0nd2hpdGUnJTNFJUYwJTlGJThGJUFGJTNDL3RleHQlM0UlM0Mvc3ZnJTNFIiwic2l6ZXMiOiIxOTJ4MTkyIiwidHlwZSI6ImltYWdlL3N2Zyt4bWwiLCJwdXJwb3NlIjoiYW55IG1hc2thYmxlIn1dfQ==">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="××•×¨×” ×“×¨×š ×™×¤×Ÿ">
    
    <!-- Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Heebo:wght@300;400;500;700;900&family=Assistant:wght@300;400;600;700&display=swap" rel="stylesheet">
    
    <!-- EXIF.js library for reading image metadata -->
    <script src="https://cdn.jsdelivr.net/npm/exif-js"></script>
    <!-- HEIC to JPEG converter -->
    <script src="https://cdn.jsdelivr.net/npm/heic2any@0.0.4/dist/heic2any.min.js"></script>
    
    <style>
        :root {
            --japan-red: #C41E3A;
            --japan-white: #FFFFFF;
            --japan-black: #1A1A1A;
            --sakura-pink: #FFB7C5;
            --bamboo-green: #2D5016;
            --sky-blue: #E8F4F8;
            --gold: #D4AF37;
            --shadow: 0 4px 20px rgba(196, 30, 58, 0.1);
            --shadow-heavy: 0 8px 40px rgba(196, 30, 58, 0.2);
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Assistant', 'Heebo', sans-serif;
            background: linear-gradient(135deg, var(--sky-blue) 0%, var(--japan-white) 100%);
            color: var(--japan-black);
            min-height: 100vh;
            padding-bottom: 80px;
        }
        
        .header {
            background: linear-gradient(135deg, var(--japan-red) 0%, #8B0000 100%);
            color: var(--japan-white);
            padding: 20px;
            text-align: center;
            box-shadow: var(--shadow-heavy);
            position: sticky;
            top: 0;
            z-index: 100;
        }
        
        .header h1 {
            font-family: 'Heebo', sans-serif;
            font-weight: 900;
            font-size: 1.8rem;
            margin-bottom: 5px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }
        
        .header .subtitle {
            font-size: 0.9rem;
            opacity: 0.95;
            font-weight: 300;
        }
        
        .container {
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
        }
        
        .card {
            background: white;
            border-radius: 16px;
            padding: 24px;
            margin-bottom: 20px;
            box-shadow: var(--shadow);
            border: 2px solid transparent;
            transition: all 0.3s ease;
        }
        
        .card:hover {
            box-shadow: var(--shadow-heavy);
            border-color: var(--sakura-pink);
            transform: translateY(-2px);
        }
        
        .camera-section {
            text-align: center;
        }
        
        .camera-btn {
            background: linear-gradient(135deg, var(--japan-red) 0%, #8B0000 100%);
            color: white;
            border: none;
            border-radius: 50%;
            width: 80px;
            height: 80px;
            font-size: 2.5rem;
            cursor: pointer;
            box-shadow: var(--shadow-heavy);
            transition: all 0.3s ease;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            margin: 10px;
        }
        
        .camera-btn:hover {
            transform: scale(1.1);
            box-shadow: 0 12px 50px rgba(196, 30, 58, 0.4);
        }
        
        .camera-btn:active {
            transform: scale(0.95);
        }
        
        .upload-btn {
            background: linear-gradient(135deg, var(--bamboo-green) 0%, #1a3510 100%);
        }
        
        .preview-container {
            margin: 20px 0;
            text-align: center;
        }
        
        .preview-image {
            max-width: 100%;
            max-height: 400px;
            border-radius: 12px;
            box-shadow: var(--shadow);
            margin: 15px 0;
        }
        
        .loading {
            display: none;
            text-align: center;
            padding: 30px;
        }
        
        .loading.active {
            display: block;
        }
        
        .spinner {
            width: 60px;
            height: 60px;
            border: 4px solid var(--sakura-pink);
            border-top: 4px solid var(--japan-red);
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .progress-container {
            width: 100%;
            max-width: 400px;
            margin: 0 auto 20px;
        }
        
        .progress-bar {
            width: 100%;
            height: 30px;
            background: #f0f0f0;
            border-radius: 15px;
            overflow: hidden;
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.1);
        }
        
        .progress-fill {
            height: 100%;
            width: 0%;
            background: linear-gradient(90deg, var(--japan-red) 0%, var(--sakura-pink) 100%);
            transition: width 0.3s ease;
            border-radius: 15px;
            position: relative;
            overflow: hidden;
        }
        
        .progress-fill::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(90deg, transparent 0%, rgba(255,255,255,0.3) 50%, transparent 100%);
            animation: shimmer 2s infinite;
        }
        
        @keyframes shimmer {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(100%); }
        }
        
        .progress-text {
            text-align: center;
            margin-top: 10px;
            font-weight: 700;
            font-size: 1.2rem;
            color: var(--japan-red);
        }
        
        .progress-steps {
            margin: 20px 0;
            text-align: right;
        }
        
        .step {
            padding: 8px 15px;
            margin: 5px 0;
            background: #f8f8f8;
            border-radius: 8px;
            font-size: 0.95rem;
            transition: all 0.3s ease;
        }
        
        .step.active {
            background: linear-gradient(90deg, var(--sky-blue) 0%, rgba(232, 244, 248, 0.3) 100%);
            border-right: 4px solid var(--japan-red);
            font-weight: 600;
        }
        
        .step.done {
            background: linear-gradient(90deg, #d4edda 0%, rgba(212, 237, 218, 0.3) 100%);
            border-right: 4px solid var(--bamboo-green);
            color: var(--bamboo-green);
        }
        
        .result-section {
            display: none;
            animation: slideIn 0.5s ease;
        }
        
        .result-section.active {
            display: block;
        }
        
        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
        
        .result-title {
            color: var(--japan-red);
            font-size: 1.5rem;
            font-weight: 700;
            margin-bottom: 15px;
            border-bottom: 3px solid var(--sakura-pink);
            padding-bottom: 10px;
        }
        
        .result-content {
            line-height: 1.8;
            font-size: 1.05rem;
            white-space: pre-wrap;
        }
        
        .audio-controls {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin: 20px 0;
            flex-wrap: wrap;
        }
        
        .audio-btn {
            background: var(--gold);
            color: var(--japan-black);
            border: none;
            padding: 12px 24px;
            border-radius: 25px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 1rem;
            box-shadow: var(--shadow);
        }
        
        .audio-btn:hover {
            background: #FFD700;
            transform: translateY(-2px);
            box-shadow: var(--shadow-heavy);
        }
        
        .audio-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .location-info {
            background: linear-gradient(135deg, var(--sky-blue) 0%, rgba(232, 244, 248, 0.3) 100%);
            padding: 15px;
            border-radius: 12px;
            margin: 15px 0;
            border-right: 4px solid var(--japan-red);
        }
        
        .warning {
            background: #FFF3CD;
            color: #856404;
            padding: 15px;
            border-radius: 12px;
            border-right: 4px solid #FFC107;
            margin: 15px 0;
        }
        
        .history-item {
            background: white;
            border-radius: 12px;
            padding: 15px;
            margin-bottom: 15px;
            box-shadow: var(--shadow);
            cursor: pointer;
            transition: all 0.3s ease;
            border-right: 4px solid var(--sakura-pink);
        }
        
        .history-item:hover {
            transform: translateX(-5px);
            box-shadow: var(--shadow-heavy);
        }
        
        .history-item img {
            width: 80px;
            height: 80px;
            object-fit: cover;
            border-radius: 8px;
            float: right;
            margin-left: 15px;
        }
        
        .history-date {
            color: var(--japan-red);
            font-size: 0.85rem;
            font-weight: 600;
        }
        
        .history-title {
            font-weight: 600;
            margin: 5px 0;
        }
        
        .history-preview {
            color: #666;
            font-size: 0.9rem;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        
        .tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            border-bottom: 2px solid var(--sakura-pink);
        }
        
        .tab {
            background: transparent;
            border: none;
            padding: 12px 24px;
            cursor: pointer;
            font-weight: 600;
            color: var(--japan-black);
            border-bottom: 3px solid transparent;
            transition: all 0.3s ease;
            font-size: 1rem;
        }
        
        .tab.active {
            color: var(--japan-red);
            border-bottom-color: var(--japan-red);
        }
        
        .tab:hover {
            background: var(--sky-blue);
        }
        
        .hidden {
            display: none !important;
        }
        
        input[type="file"] {
            display: none;
        }
        
        .status-bar {
            background: var(--japan-black);
            color: white;
            padding: 8px 20px;
            text-align: center;
            font-size: 0.85rem;
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            z-index: 1000;
        }
        
        .status-bar.online {
            background: var(--bamboo-green);
        }
        
        .status-bar.offline {
            background: var(--japan-red);
        }
        
        .settings-section {
            margin-top: 20px;
            padding-top: 20px;
            border-top: 2px solid var(--sakura-pink);
        }
        
        .settings-label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: var(--japan-red);
        }
        
        .settings-input {
            width: 100%;
            padding: 12px;
            border: 2px solid var(--sakura-pink);
            border-radius: 8px;
            font-size: 1rem;
            font-family: 'Assistant', sans-serif;
        }
        
        @media (max-width: 600px) {
            .header h1 {
                font-size: 1.4rem;
            }
            
            .camera-btn {
                width: 70px;
                height: 70px;
                font-size: 2rem;
            }
            
            .container {
                padding: 15px;
            }
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>ğŸ¯ ××•×¨×” ×“×¨×š ×™×¤×Ÿ</h1>
        <div class="subtitle">×”××“×¨×™×š ×”××™×©×™ ×©×œ×š - ××•×¤×¢×œ ×¢×œ ×™×“×™ ×‘×™× ×” ××œ××›×•×ª×™×ª</div>
    </div>

    <div class="container">
        <div class="tabs">
            <button class="tab active" onclick="switchTab('camera')">ğŸ“¸ ××¦×œ××”</button>
            <button class="tab" onclick="switchTab('history')">ğŸ“š ×”×™×¡×˜×•×¨×™×”</button>
            <button class="tab" onclick="switchTab('settings')">âš™ï¸ ×”×’×“×¨×•×ª</button>
        </div>

        <!-- Camera Tab -->
        <div id="cameraTab" class="tab-content">
            <div class="card camera-section">
                <h2 style="margin-bottom: 20px; color: var(--japan-red);">×¦×œ× ××• ×”×¢×œ×” ×ª××•× ×”</h2>
                <p style="margin-bottom: 20px; color: #666;">×¦×œ× ××§×“×©, × ×•×£, ×›×ª×•×‘×ª ××• ×›×œ ×“×‘×¨ ××¢× ×™×™×Ÿ ×•×ª×§×‘×œ ×”×¡×‘×¨ ××¤×•×¨×˜!</p>
                
                <div>
                    <button class="camera-btn" onclick="openCamera()" title="×¦×œ× ×ª××•× ×”">ğŸ“·</button>
                    <button class="camera-btn upload-btn" onclick="document.getElementById('fileInput').click()" title="×”×¢×œ×” ××”×’×œ×¨×™×”">ğŸ–¼ï¸</button>
                </div>
                
                <input type="file" id="fileInput" accept="image/*,.heic,.heif" onchange="handleFileSelect(event)">
                <input type="file" id="cameraInput" accept="image/*,.heic,.heif" capture="environment" onchange="handleFileSelect(event)">
            </div>

            <div class="preview-container" id="previewContainer" style="display: none;">
                <div class="card">
                    <img id="previewImage" class="preview-image" alt="×ª××•× ×”">
                    <div class="location-info" id="locationInfo" style="display: none;">
                        <strong>ğŸ“ ××™×§×•×:</strong>
                        <div id="coordinates"></div>
                    </div>
                    <div class="warning" id="noLocationWarning" style="display: none;">
                        âš ï¸ ×œ× × ××¦××• × ×ª×•× ×™ ××™×§×•× ×‘×ª××•× ×”. ×”×”×¡×‘×¨ ×™×”×™×” ×›×œ×œ×™ ×™×•×ª×¨.
                    </div>
                    <button class="audio-btn" onclick="analyzeImage()" style="width: 100%; margin-top: 15px;">
                        ğŸ” × ×ª×— ××ª ×”×ª××•× ×”
                    </button>
                </div>
            </div>

            <div class="loading" id="loading">
                <div class="progress-container">
                    <div class="progress-bar">
                        <div class="progress-fill" id="progressFill"></div>
                    </div>
                    <div class="progress-text" id="progressPercent">0%</div>
                </div>
                <h3 id="loadingTitle">××›×™×Ÿ ××ª ×”×ª××•× ×”...</h3>
                <div class="progress-steps" id="progressSteps">
                    <div class="step" id="step1">â³ ××¢×œ×” ×ª××•× ×”...</div>
                    <div class="step" id="step2">â¬œ ×©×•×œ×— ×œ-Claude AI...</div>
                    <div class="step" id="step3">â¬œ ×× ×ª×— ×ª××•× ×”...</div>
                    <div class="step" id="step4">â¬œ ××›×™×Ÿ ×”×¡×‘×¨...</div>
                </div>
                <p id="loadingText" style="font-size: 0.9rem; color: #999; margin-top: 15px;">×–××Ÿ ××©×•×¢×¨: 20-40 ×©× ×™×•×ª</p>
            </div>

            <div class="result-section" id="resultSection">
                <div class="card">
                    <h2 class="result-title" id="resultTitle">×ª×•×¦××•×ª</h2>
                    <div class="audio-controls">
                        <button class="audio-btn" onclick="readAloud()">ğŸ”Š ×”×§×¨× ×œ×™</button>
                        <button class="audio-btn" onclick="stopReading()">â¸ï¸ ×¢×¦×•×¨</button>
                        <button class="audio-btn" onclick="downloadText()">ğŸ’¾ ×”×•×¨×“ ×§×•×‘×¥ TXT</button>
                        <button class="audio-btn" onclick="saveToHistory()">ğŸ“š ×©××•×¨ ×œ×”×™×¡×˜×•×¨×™×”</button>
                    </div>
                    <p style="font-size: 0.85rem; color: #999; text-align: center; margin-top: -10px;">
                        ğŸ’¡ ×œ×”×§×¨××” ×‘-@Voice: ×”×•×¨×“ ×§×•×‘×¥ TXT ×•×¤×ª×— ××•×ª×• ×‘××¤×œ×™×§×¦×™×”
                    </p>
                    <div class="result-content" id="resultContent"></div>
                </div>
            </div>
        </div>

        <!-- History Tab -->
        <div id="historyTab" class="tab-content hidden">
            <div class="card">
                <h2 style="color: var(--japan-red); margin-bottom: 20px;">×”×”×™×¡×˜×•×¨×™×” ×©×œ×š</h2>
                <p style="color: #666; margin-bottom: 20px;">×›×œ ×”××§×•××•×ª ×©×‘×”× ×‘×™×§×¨×ª ×•×”×¡×‘×¨×™× ×©×§×™×‘×œ×ª</p>
                <div id="historyList"></div>
                <button class="audio-btn" onclick="exportDiary()" style="width: 100%; margin-top: 20px;">
                    ğŸ“„ ×™×™×¦× ×™×•××Ÿ ×˜×™×•×œ
                </button>
            </div>
        </div>

        <!-- Settings Tab -->
        <div id="settingsTab" class="tab-content hidden">
            <div class="card">
                <h2 style="color: var(--japan-red); margin-bottom: 20px;">×”×’×“×¨×•×ª</h2>
                
                <div class="settings-section">
                    <label class="settings-label">ğŸ”‘ ××¤×ª×— API ×©×œ Claude (Anthropic)</label>
                    <div style="display: flex; gap: 10px; align-items: center;">
                        <input 
                            type="password" 
                            id="apiKey" 
                            class="settings-input" 
                            placeholder="×”×›× ×¡ ××ª ××¤×ª×— ×”-API ×©×œ×š"
                            value=""
                            style="flex: 1;"
                        >
                        <button class="audio-btn" onclick="toggleApiKeyVisibility()" style="margin: 0; padding: 12px 20px;">
                            ğŸ‘ï¸
                        </button>
                    </div>
                    <p style="color: #666; font-size: 0.9rem; margin-top: 8px;">
                        ğŸ’¡ ×§×‘×œ ××¤×ª×— API ×‘×—×™× × ×‘-<a href="https://console.anthropic.com/" target="_blank" style="color: var(--japan-red);">console.anthropic.com</a>
                    </p>
                    <button class="audio-btn" onclick="saveApiKey()" style="margin-top: 15px;">ğŸ’¾ ×©××•×¨ ×”×’×“×¨×•×ª</button>
                    <p id="apiKeyStatus" style="margin-top: 10px; font-size: 0.9rem;"></p>
                </div>

                <div class="settings-section">
                    <h3 style="color: var(--bamboo-green); margin-bottom: 15px;">ğŸ—ºï¸ ×–×™×”×•×™ ××§×•××•×ª</h3>
                    <p style="color: #666; line-height: 1.6;">
                        âœ… ×”××¤×œ×™×§×¦×™×” ××©×ª××©×ª ×‘-<strong>OpenStreetMap</strong> ×œ×–×™×”×•×™ ××§×•××•×ª ×œ×¤×™ GPS<br>
                        ğŸ¯ ×—×™× ××™ ×œ×’××¨×™ ×œ×œ× ×¦×•×¨×š ×‘××¤×ª×— API<br>
                        ğŸŒ ××“×•×™×§ ×‘××™×•×—×“ ×œ××§×•××•×ª ×ª×™×™×¨×•×ª×™×™× ××¤×•×¨×¡××™×
                    </p>
                </div>

                <div class="settings-section">
                    <h3 style="color: var(--bamboo-green); margin-bottom: 15px;">ğŸ“Š ×¡×˜×˜×™×¡×˜×™×§×•×ª</h3>
                    <p>×ª××•× ×•×ª × ×•×ª×—×•: <strong id="statsImages">0</strong></p>
                    <p>××§×•××•×ª ×‘×”×™×¡×˜×•×¨×™×”: <strong id="statsHistory">0</strong></p>
                    <p style="margin-top: 10px; font-size: 0.9rem; color: #666;">
                        ×¢×œ×•×ª ××©×•×¢×¨×ª: $<span id="statsEstimatedCost">0.00</span>
                    </p>
                </div>

                <div class="settings-section">
                    <h3 style="color: var(--japan-red); margin-bottom: 15px;">ğŸ—‘ï¸ × ×™×§×•×™ × ×ª×•× ×™×</h3>
                    <button class="audio-btn" onclick="clearHistory()" style="background: #dc3545;">
                        ğŸ—‘ï¸ ××—×§ ×”×™×¡×˜×•×¨×™×”
                    </button>
                </div>
            </div>
        </div>
    </div>

    <div class="status-bar online" id="statusBar">
        ğŸŸ¢ ××—×•×‘×¨ ×œ××™× ×˜×¨× ×˜
    </div>

    <script>
        // Global variables
        let currentImage = null;
        let currentImageData = null;
        let currentResult = null;
        let currentLocation = null;
        let currentPhotoDate = null; // Store actual photo date from EXIF
        let speechSynthesis = window.speechSynthesis;
        let currentUtterance = null;
        let wakeLock = null;
        let previousComplex = null; // Store only the last complex/venue
        let analysisHistory = []; // Keep history for statistics only
        
        // IndexedDB for storing full-size images
        const DB_NAME = 'JapanGuideDB';
        const DB_VERSION = 1;
        const STORE_NAME = 'images';
        let db = null;
        
        // Initialize IndexedDB
        async function initIndexedDB() {
            try {
                return new Promise((resolve, reject) => {
                    const request = indexedDB.open(DB_NAME, DB_VERSION);
                    
                    request.onerror = () => {
                        console.error('IndexedDB error:', request.error);
                        reject(request.error);
                    };
                    
                    request.onsuccess = () => {
                        db = request.result;
                        console.log('âœ… IndexedDB initialized');
                        resolve(db);
                    };
                    
                    request.onupgradeneeded = (event) => {
                        const db = event.target.result;
                        if (!db.objectStoreNames.contains(STORE_NAME)) {
                            const objectStore = db.createObjectStore(STORE_NAME, { keyPath: 'id' });
                            objectStore.createIndex('timestamp', 'timestamp', { unique: false });
                            console.log('âœ… IndexedDB object store created');
                        }
                    };
                });
            } catch (error) {
                console.error('Failed to initialize IndexedDB:', error);
                return null;
            }
        }
        
        // Save image to IndexedDB
        async function saveImageToIndexedDB(id, imageData, metadata) {
            try {
                if (!db) {
                    await initIndexedDB();
                }
                
                if (!db) {
                    console.warn('IndexedDB not available, skipping image save');
                    return false;
                }
                
                return new Promise((resolve, reject) => {
                    const transaction = db.transaction([STORE_NAME], 'readwrite');
                    const objectStore = transaction.objectStore(STORE_NAME);
                    
                    const record = {
                        id: id,
                        imageData: imageData,
                        timestamp: Date.now(),
                        ...metadata
                    };
                    
                    const request = objectStore.put(record);
                    
                    request.onsuccess = () => {
                        console.log('âœ… Image saved to IndexedDB:', id);
                        resolve(true);
                    };
                    
                    request.onerror = () => {
                        console.error('Failed to save image to IndexedDB:', request.error);
                        reject(request.error);
                    };
                });
            } catch (error) {
                console.error('saveImageToIndexedDB error:', error);
                return false;
            }
        }
        
        // Get image from IndexedDB
        async function getImageFromIndexedDB(id) {
            try {
                if (!db) {
                    await initIndexedDB();
                }
                
                if (!db) {
                    return null;
                }
                
                return new Promise((resolve, reject) => {
                    const transaction = db.transaction([STORE_NAME], 'readonly');
                    const objectStore = transaction.objectStore(STORE_NAME);
                    const request = objectStore.get(id);
                    
                    request.onsuccess = () => {
                        resolve(request.result);
                    };
                    
                    request.onerror = () => {
                        console.error('Failed to get image from IndexedDB:', request.error);
                        reject(request.error);
                    };
                });
            } catch (error) {
                console.error('getImageFromIndexedDB error:', error);
                return null;
            }
        }
        
        // Get all images from IndexedDB
        async function getAllImagesFromIndexedDB() {
            try {
                if (!db) {
                    await initIndexedDB();
                }
                
                if (!db) {
                    return [];
                }
                
                return new Promise((resolve, reject) => {
                    const transaction = db.transaction([STORE_NAME], 'readonly');
                    const objectStore = transaction.objectStore(STORE_NAME);
                    const request = objectStore.getAll();
                    
                    request.onsuccess = () => {
                        resolve(request.result || []);
                    };
                    
                    request.onerror = () => {
                        console.error('Failed to get all images:', request.error);
                        reject(request.error);
                    };
                });
            } catch (error) {
                console.error('getAllImagesFromIndexedDB error:', error);
                return [];
            }
        }
        
        // Delete old images to free space (keep only last 100)
        async function cleanupOldImages() {
            try {
                const allImages = await getAllImagesFromIndexedDB();
                
                if (allImages.length > 100) {
                    // Sort by timestamp
                    allImages.sort((a, b) => a.timestamp - b.timestamp);
                    
                    // Delete oldest ones
                    const toDelete = allImages.slice(0, allImages.length - 100);
                    
                    const transaction = db.transaction([STORE_NAME], 'readwrite');
                    const objectStore = transaction.objectStore(STORE_NAME);
                    
                    for (let image of toDelete) {
                        objectStore.delete(image.id);
                    }
                    
                    console.log(`ğŸ—‘ï¸ Cleaned up ${toDelete.length} old images`);
                }
            } catch (error) {
                console.error('cleanupOldImages error:', error);
            }
        }
        
        // Initialize IndexedDB on load
        initIndexedDB().catch(err => {
            console.warn('IndexedDB initialization failed, will use localStorage only:', err);
        });
        
        // Check online status
        function updateOnlineStatus() {
            const statusBar = document.getElementById('statusBar');
            if (navigator.onLine) {
                statusBar.textContent = 'ğŸŸ¢ ××—×•×‘×¨ ×œ××™× ×˜×¨× ×˜';
                statusBar.className = 'status-bar online';
            } else {
                statusBar.textContent = 'ğŸ”´ ××™×Ÿ ×—×™×‘×•×¨ ×œ××™× ×˜×¨× ×˜';
                statusBar.className = 'status-bar offline';
            }
        }
        
        // Create thumbnail from image
        async function createThumbnail(dataUrl, maxWidth, maxHeight) {
            try {
                return new Promise((resolve, reject) => {
                    const img = new Image();
                    
                    img.onload = function() {
                        try {
                            const canvas = document.createElement('canvas');
                            const ctx = canvas.getContext('2d');
                            
                            // Calculate thumbnail size maintaining aspect ratio
                            let width = img.width;
                            let height = img.height;
                            
                            if (width > height) {
                                if (width > maxWidth) {
                                    height = (height / width) * maxWidth;
                                    width = maxWidth;
                                }
                            } else {
                                if (height > maxHeight) {
                                    width = (width / height) * maxHeight;
                                    height = maxHeight;
                                }
                            }
                            
                            canvas.width = width;
                            canvas.height = height;
                            ctx.drawImage(img, 0, 0, width, height);
                            
                            // Convert to JPEG with compression
                            const thumbnailData = canvas.toDataURL('image/jpeg', 0.7);
                            resolve(thumbnailData);
                        } catch (error) {
                            console.error('Error creating thumbnail canvas:', error);
                            // Fallback: return original image
                            resolve(dataUrl);
                        }
                    };
                    
                    img.onerror = function() {
                        console.error('Error loading image for thumbnail');
                        // Fallback: return original image
                        resolve(dataUrl);
                    };
                    
                    img.src = dataUrl;
                });
            } catch (error) {
                console.error('createThumbnail error:', error);
                // Fallback: return original image
                return dataUrl;
            }
        }

        window.addEventListener('online', updateOnlineStatus);
        window.addEventListener('offline', updateOnlineStatus);

        // Tab switching
        function switchTab(tabName) {
            const clickedTab = event.target;
            document.querySelectorAll('.tab').forEach(tab => tab.classList.remove('active'));
            document.querySelectorAll('.tab-content').forEach(content => content.classList.add('hidden'));
            
            clickedTab.classList.add('active');
            document.getElementById(tabName + 'Tab').classList.remove('hidden');
            
            if (tabName === 'history') {
                loadHistory();
            } else if (tabName === 'settings') {
                updateStats();
            }
        }

        // Open camera
        function openCamera() {
            document.getElementById('cameraInput').click();
        }

        // Compress image - optimize for speed (faster upload)
        function compressImage(dataUrl, callback) {
            const img = new Image();
            img.onload = function() {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                
                // Calculate new dimensions - smaller for faster upload (max 1200px)
                let width = img.width;
                let height = img.height;
                const maxSize = 1200; // Reduced from 1600 for faster upload
                
                if (width > maxSize || height > maxSize) {
                    if (width > height) {
                        height = (height / width) * maxSize;
                        width = maxSize;
                    } else {
                        width = (width / height) * maxSize;
                        height = maxSize;
                    }
                }
                
                canvas.width = width;
                canvas.height = height;
                
                // Draw and compress
                ctx.drawImage(img, 0, 0, width, height);
                
                // Target 1.5MB for faster upload while maintaining quality
                let quality = 0.75;
                let compressedDataUrl = canvas.toDataURL('image/jpeg', quality);
                const targetSize = 1.5 * 1024 * 1024; // 1.5MB - faster upload
                
                // Keep reducing quality if still too large
                while (compressedDataUrl.length > targetSize && quality > 0.4) {
                    quality -= 0.1;
                    compressedDataUrl = canvas.toDataURL('image/jpeg', quality);
                }
                
                // Log compression info
                const originalSize = (dataUrl.length / 1024 / 1024).toFixed(2);
                const compressedSize = (compressedDataUrl.length / 1024 / 1024).toFixed(2);
                console.log(`×ª××•× ×” × ×“×—×¡×”: ${originalSize}MB â†’ ${compressedSize}MB (××™×›×•×ª: ${(quality * 100).toFixed(0)}%)`);
                
                callback(compressedDataUrl);
            };
            img.src = dataUrl;
        }

        // Handle file selection
        async function handleFileSelect(event) {
            const file = event.target.files[0];
            if (!file) return;

            // Reset state for new image
            currentPhotoDate = null;
            currentLocation = null;

            // Check if this is from camera (newly taken photo)
            const isFromCamera = event.target.id === 'cameraInput';

            // Show a temporary loading message for HEIC files
            const isHEIC = file.type === 'image/heic' || file.type === 'image/heif' || 
                          file.name.toLowerCase().endsWith('.heic') || 
                          file.name.toLowerCase().endsWith('.heif');
            
            if (isHEIC) {
                // Show converting message
                const loadingDiv = document.createElement('div');
                loadingDiv.id = 'heicLoading';
                loadingDiv.style.cssText = 'position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: white; padding: 30px; border-radius: 12px; box-shadow: 0 4px 20px rgba(0,0,0,0.2); z-index: 9999; text-align: center;';
                loadingDiv.innerHTML = '<div style="font-size: 1.2rem; color: #C41E3A; margin-bottom: 10px;">ğŸ”„ ×××™×¨ ×ª××•× ×ª HEIC...</div><div style="color: #666;">×–×” ×™×›×•×œ ×œ×§×—×ª ×›××” ×©× ×™×•×ª</div>';
                document.body.appendChild(loadingDiv);
                
                try {
                    // Convert HEIC to JPEG
                    const convertedBlob = await heic2any({
                        blob: file,
                        toType: 'image/jpeg',
                        quality: 0.9
                    });
                    
                    // Create a new File from the converted blob
                    currentImage = new File([convertedBlob], file.name.replace(/\.heic$/i, '.jpg'), {
                        type: 'image/jpeg'
                    });
                    
                    // Remove loading message
                    document.body.removeChild(loadingDiv);
                } catch (error) {
                    document.body.removeChild(loadingDiv);
                    alert('âŒ ×©×’×™××” ×‘×”××¨×ª ×ª××•× ×ª HEIC!\n\n×¤×ª×¨×•× ×•×ª:\n1. ×©×ª×£ ××ª ×”×ª××•× ×” ×“×¨×š Google Photos (×–×” ×××™×¨ ××•×˜×•××˜×™×ª)\n2. ×©× ×” ××ª ×”×’×“×¨×•×ª ×”××¦×œ××” ×œ-JPG\n3. ×”×©×ª××© ×‘××¤×œ×™×§×¦×™×™×ª ×”××¨×”');
                    return;
                }
            } else {
                currentImage = file;
            }
            
            // Try to extract EXIF GPS data from the image
            extractGPSFromImage(currentImage, isFromCamera);
            
            // Show preview and compress image
            const reader = new FileReader();
            reader.onload = function(e) {
                // Compress image before storing
                compressImage(e.target.result, function(compressedDataUrl) {
                    currentImageData = compressedDataUrl;
                    document.getElementById('previewImage').src = compressedDataUrl;
                    document.getElementById('previewContainer').style.display = 'block';
                });
            };
            reader.readAsDataURL(currentImage);
        }

        // Extract GPS coordinates from image EXIF data
        function extractGPSFromImage(file, isFromCamera) {
            // Simple logic:
            // Camera photo â†’ Use Geolocation (phone's GPS)
            // Gallery photo â†’ Try EXIF only
            
            if (isFromCamera) {
                // Camera photo - always get GPS from phone
                console.log('ğŸ“· Camera photo - getting GPS from phone');
                getCurrentLocation();
                // Use current date for camera photos
                currentPhotoDate = new Date();
                return;
            }
            
            // Gallery photo - try EXIF only
            console.log('ğŸ–¼ï¸ Gallery photo - trying EXIF GPS and date');
            
            EXIF.getData(file, function() {
                try {
                    // Read GPS data
                    const lat = EXIF.getTag(this, 'GPSLatitude');
                    const lon = EXIF.getTag(this, 'GPSLongitude');
                    const latRef = EXIF.getTag(this, 'GPSLatitudeRef') || 'N';
                    const lonRef = EXIF.getTag(this, 'GPSLongitudeRef') || 'E';
                    
                    // Read photo date
                    const dateTimeOriginal = EXIF.getTag(this, 'DateTimeOriginal');
                    const dateTime = EXIF.getTag(this, 'DateTime');
                    const exifDate = dateTimeOriginal || dateTime;
                    
                    console.log('EXIF Data:', { lat, lon, latRef, lonRef, date: exifDate });
                    
                    // Parse EXIF date (format: "YYYY:MM:DD HH:MM:SS")
                    if (exifDate) {
                        try {
                            const parts = exifDate.split(' ');
                            const datePart = parts[0].replace(/:/g, '-');
                            const timePart = parts[1] || '00:00:00';
                            currentPhotoDate = new Date(datePart + 'T' + timePart);
                            console.log('âœ… Photo date from EXIF:', currentPhotoDate.toISOString());
                        } catch (dateError) {
                            console.warn('âŒ Could not parse EXIF date:', exifDate);
                            currentPhotoDate = new Date(); // Fallback to current date
                        }
                    } else {
                        console.log('â„¹ï¸ No EXIF date found, using current date');
                        currentPhotoDate = new Date();
                    }
                    
                    if (lat && lon && Array.isArray(lat) && Array.isArray(lon)) {
                        // Convert GPS coordinates to decimal
                        const latitude = convertDMSToDD(lat[0], lat[1], lat[2], latRef);
                        const longitude = convertDMSToDD(lon[0], lon[1], lon[2], lonRef);
                        
                        // Validate coordinates
                        if (!isNaN(latitude) && !isNaN(longitude) && 
                            latitude >= -90 && latitude <= 90 && 
                            longitude >= -180 && longitude <= 180) {
                            currentLocation = { latitude, longitude };
                            showLocation(currentLocation);
                            console.log('âœ… GPS extracted from EXIF:', currentLocation);
                        } else {
                            console.log('âŒ Invalid GPS coordinates from EXIF');
                            showNoLocation();
                        }
                    } else {
                        console.log('âŒ No EXIF GPS data found');
                        showNoLocation();
                    }
                } catch (error) {
                    console.error('âŒ Error reading EXIF:', error);
                    currentPhotoDate = new Date(); // Fallback
                    showNoLocation();
                }
            });
        }

        // Convert DMS (Degrees, Minutes, Seconds) to Decimal Degrees
        function convertDMSToDD(degrees, minutes, seconds, direction) {
            // Handle different data types
            let d = parseFloat(degrees);
            let m = parseFloat(minutes);
            let s = parseFloat(seconds);
            
            // Validate numbers
            if (isNaN(d) || isNaN(m) || isNaN(s)) {
                console.error('Invalid DMS values:', { degrees, minutes, seconds });
                return NaN;
            }
            
            let dd = d + m / 60 + s / 3600;
            
            if (direction === 'S' || direction === 'W') {
                dd = dd * -1;
            }
            
            return dd;
        }

        // Get current location with better accuracy
        function getCurrentLocation() {
            if (navigator.geolocation) {
                // Show loading message
                document.getElementById('locationInfo').style.display = 'block';
                document.getElementById('coordinates').textContent = '×××ª×¨ ××™×§×•× ××“×•×™×§...';
                document.getElementById('noLocationWarning').style.display = 'none';
                
                navigator.geolocation.getCurrentPosition(
                    function(position) {
                        const accuracy = position.coords.accuracy;
                        
                        currentLocation = {
                            latitude: position.coords.latitude,
                            longitude: position.coords.longitude,
                            accuracy: accuracy
                        };
                        
                        showLocation(currentLocation);
                        
                        // Warn if accuracy is poor
                        if (accuracy > 100) {
                            const warningEl = document.getElementById('noLocationWarning');
                            warningEl.style.display = 'block';
                            warningEl.style.background = '#fff3cd';
                            warningEl.style.borderRight = '4px solid #ffc107';
                            warningEl.innerHTML = `âš ï¸ ×“×™×•×§ ×”××™×§×•× × ××•×š (Â±${Math.round(accuracy)} ××˜×¨).<br>×œ×“×™×•×§ ×˜×•×‘ ×™×•×ª×¨: ×”××ª×Ÿ ××¡×¤×¨ ×©× ×™×•×ª ××• ×¦× ×œ×©×˜×— ×¤×ª×•×—.`;
                        }
                    },
                    function(error) {
                        console.error('GPS error:', error);
                        showNoLocation();
                    },
                    {
                        enableHighAccuracy: true,      // Use GPS, not cell towers
                        timeout: 10000,                // Wait up to 10 seconds
                        maximumAge: 0                  // Don't use cached location
                    }
                );
            } else {
                showNoLocation();
            }
        }

        function showLocation(coords) {
            // Validate coordinates before showing
            if (!coords || isNaN(coords.latitude) || isNaN(coords.longitude)) {
                console.error('Invalid coordinates:', coords);
                showNoLocation();
                return;
            }
            
            document.getElementById('locationInfo').style.display = 'block';
            document.getElementById('noLocationWarning').style.display = 'none';
            
            let coordText = `×§×• ×¨×•×—×‘: ${coords.latitude.toFixed(6)}, ×§×• ××•×¨×š: ${coords.longitude.toFixed(6)}`;
            
            // Add accuracy info if available
            if (coords.accuracy) {
                const accuracyText = coords.accuracy < 50 ? '××“×•×™×§' : coords.accuracy < 100 ? '×˜×•×‘' : '× ××•×š';
                coordText += `\n(×“×™×•×§: Â±${Math.round(coords.accuracy)}×' - ${accuracyText})`;
            }
            
            document.getElementById('coordinates').textContent = coordText;
        }

        function showNoLocation() {
            currentLocation = null;
            document.getElementById('locationInfo').style.display = 'none';
            document.getElementById('noLocationWarning').style.display = 'block';
        }

        // Reverse geocoding - find place name from GPS coordinates using OpenStreetMap
        async function getPlaceNameFromGPS(latitude, longitude) {
            try {
                console.log(`ğŸ—ºï¸ Searching place name for: ${latitude}, ${longitude}`);
                
                // OpenStreetMap Nominatim - free, no API key needed!
                const url = `https://nominatim.openstreetmap.org/reverse?format=json&lat=${latitude}&lon=${longitude}&zoom=18&addressdetails=1`;
                
                const response = await fetch(url, {
                    headers: {
                        'User-Agent': 'JapanTravelGuide/1.0' // Required by Nominatim
                    }
                });
                
                const data = await response.json();
                
                if (data && data.display_name) {
                    let placeName = null;
                    
                    // Try to get specific place name from address details
                    if (data.address) {
                        // Priority order for place types
                        placeName = data.address.tourism ||           // Tourist attractions
                                   data.address.amenity ||            // Temples, shrines, etc.
                                   data.address.historic ||           // Historic sites
                                   data.address.building ||           // Named buildings
                                   data.address.attraction ||         // General attractions
                                   data.name ||                       // Place name if available
                                   data.address.neighbourhood ||      // Neighborhood
                                   data.address.suburb ||             // Suburb/area
                                   data.display_name.split(',')[0];  // First part of address
                    } else {
                        placeName = data.display_name.split(',')[0];
                    }
                    
                    console.log('âœ… Found place:', placeName);
                    console.log('ğŸ“ Full address:', data.display_name);
                    return placeName;
                    
                } else {
                    console.log('âŒ Nominatim returned no results');
                    return null;
                }
                
            } catch (error) {
                console.error('âŒ Error in reverse geocoding:', error);
                return null;
            }
        }

        // Progress tracking with simulation
        let progressInterval = null;
        let currentProgress = 0;
        let targetProgress = 0;
        
        function updateProgress(percent, step, stepText) {
            targetProgress = percent;
            
            const loadingTitle = document.getElementById('loadingTitle');
            if (loadingTitle && stepText) {
                loadingTitle.textContent = stepText;
            }
            
            // Update steps
            for (let i = 1; i <= 4; i++) {
                const stepEl = document.getElementById('step' + i);
                if (stepEl) {
                    if (i < step) {
                        stepEl.className = 'step done';
                        stepEl.textContent = stepEl.textContent.replace('â³', 'âœ…').replace('â¬œ', 'âœ…');
                    } else if (i === step) {
                        stepEl.className = 'step active';
                        stepEl.textContent = stepEl.textContent.replace('â¬œ', 'â³');
                    } else {
                        stepEl.className = 'step';
                    }
                }
            }
        }
        
        function startProgressSimulation() {
            currentProgress = 0;
            targetProgress = 0;
            
            // Clear any existing interval
            if (progressInterval) {
                clearInterval(progressInterval);
            }
            
            // Smooth progress animation
            progressInterval = setInterval(() => {
                const progressFill = document.getElementById('progressFill');
                const progressPercent = document.getElementById('progressPercent');
                
                if (currentProgress < targetProgress) {
                    // Fast catch up if far behind
                    const diff = targetProgress - currentProgress;
                    const increment = diff > 20 ? 2 : 0.5;
                    currentProgress = Math.min(currentProgress + increment, targetProgress);
                } else if (currentProgress < 85 && targetProgress < 85) {
                    // Slow progress during analysis (simulated)
                    currentProgress += 0.3;
                }
                
                // Cap at target
                currentProgress = Math.min(currentProgress, targetProgress);
                
                if (progressFill) {
                    progressFill.style.width = currentProgress + '%';
                }
                if (progressPercent) {
                    progressPercent.textContent = Math.round(currentProgress) + '%';
                }
                
                // Stop at 100%
                if (currentProgress >= 100) {
                    clearInterval(progressInterval);
                    progressInterval = null;
                }
            }, 100);
        }
        
        function stopProgressSimulation() {
            if (progressInterval) {
                clearInterval(progressInterval);
                progressInterval = null;
            }
        }

        // Analyze image with Claude API  
        async function analyzeImage() {
            if (!navigator.onLine) {
                alert('××™×Ÿ ×—×™×‘×•×¨ ×œ××™× ×˜×¨× ×˜! ×™×© ×¦×•×¨×š ×‘×—×™×‘×•×¨ ×›×“×™ ×œ× ×ª×— ×ª××•× ×•×ª.');
                return;
            }

            const apiKey = localStorage.getItem('claudeApiKey');
            if (!apiKey) {
                alert('× × ×œ×”×–×™×Ÿ ××¤×ª×— API ×‘×”×’×“×¨×•×ª ×ª×—×™×œ×”!');
                switchTab('settings');
                return;
            }

            // Show loading with progress simulation
            document.getElementById('loading').classList.add('active');
            document.getElementById('resultSection').classList.remove('active');
            startProgressSimulation();
            updateProgress(0, 1, '××›×™×Ÿ ××ª ×”×ª××•× ×”...');
            
            // Simulate initial progress
            setTimeout(() => updateProgress(10, 1, '××¢×œ×” ×ª××•× ×”...'), 500);
            setTimeout(() => updateProgress(30, 2, '×©×•×œ×— ×œ-Claude AI...'), 2000);
            setTimeout(() => updateProgress(60, 3, 'Claude ×× ×ª×— ××ª ×”×ª××•× ×”...'), 5000);
            setTimeout(() => updateProgress(85, 3, 'Claude ×× ×ª×— ××ª ×”×ª××•× ×”...'), 15000);

            try {
                // Log current location for debugging
                let placeName = null;
                if (currentLocation) {
                    console.log('ğŸ“ ×©×•×œ×— GPS ×œ-Claude:', currentLocation);
                    console.log(`   ×§×• ×¨×•×—×‘: ${currentLocation.latitude}`);
                    console.log(`   ×§×• ××•×¨×š: ${currentLocation.longitude}`);
                    
                    // Try to get place name from Google Maps
                    updateProgress(15, 1, '××—×¤×© ×©× ××§×•× ×‘-OpenStreetMap...');
                    placeName = await getPlaceNameFromGPS(currentLocation.latitude, currentLocation.longitude);
                    
                    if (placeName) {
                        console.log('ğŸ¯ OpenStreetMap ××¦×:', placeName);
                    } else {
                        console.log('âš ï¸ OpenStreetMap ×œ× ××¦× ×©× ××§×•× ××“×•×™×§');
                    }
                } else {
                    console.log('âš ï¸ ××™×Ÿ GPS - ×©×•×œ×— ×‘×œ×™ ××™×§×•×');
                }
                
                // Prepare context about previous complex
                let complexContext = '';
                if (previousComplex) {
                    complexContext = `\n\nğŸ“ ×”×§×©×¨ ×—×©×•×‘ - ××ª×—× ×§×•×“×:
×”××©×ª××© ×¦×™×œ× ×ª××•× ×” ×§×•×“××ª ×‘××ª×—×: "${previousComplex}"

××©×™××ª×š:
1. × ×ª×— ××ª ×”×ª××•× ×” ×”× ×•×›×—×™×ª + ×§×•××•×¨×“×™× ×˜×•×ª GPS (×× ×™×©)
2. ×–×”×”: ××”×• ×”××ª×—×/×”××ª×¨ ×”×¡×¤×¦×™×¤×™ ×©×œ ×”×ª××•× ×” ×”× ×•×›×—×™×ª?
3. ×”×©×•×•×”: ×”×× ×–×” ××•×ª×• ××ª×—× ×›××• "${previousComplex}"?

×”×’×“×¨×ª "××ª×—×":
- ××§×•× ×¢× ×©× ×¡×¤×¦×™×¤×™: ××§×“×© X, ×˜×™×¨×” Y, ×¤××¨×§ Z, ×©×•×§ W, ××¡×¢×“×” V
- ××ª×¨ ××•×’×“×¨ ×’×™××•×’×¨×¤×™×ª ×¢× ×–×”×•×ª ××©×œ×•
- ×“×•×’×××•×ª: "××§×“×© ×¡× ×¡×•×’'×™", "×’×Ÿ ×§× ×¨×•×§×•-××Ÿ", "×©×•×§ ×˜×¡×•×§×™×’'×™"

×× ×”×ª××•× ×” ×”×™× ×××•×ª×• ××ª×—×:
- ××œ ×ª×—×–×•×¨ ×¢×œ ×”×¨×§×¢ ×”×”×™×¡×˜×•×¨×™/×›×œ×œ×™ ×©× ×™×ª×Ÿ ×›×‘×¨
- ×”×ª××§×“ ×¨×§ ×‘×¤×¨×˜ ×”×¡×¤×¦×™×¤×™ ×©×‘×ª××•× ×” ×”× ×•×›×—×™×ª
- ×¦×™×™×Ÿ ×‘×§×¦×¨×”: "×–×” ×××•×§× ×‘[××ª×—×] ×©×›×‘×¨ ×‘×™×§×¨× ×• ×‘×•"
- ×”×™×” ×§×¦×¨ ×•×××•×§×“ (1-2 ×¤×¡×§××•×ª)

×× ×–×” ××ª×—× ×—×“×© ××• ×œ× ××–×•×”×”:
- ×ª×Ÿ ×”×¡×‘×¨ ××œ× ×›×¨×’×™×œ ×¢× ×¨×§×¢ ×•×”×§×©×¨`;
                } else {
                    complexContext = `\n\nğŸ“ ×”×§×©×¨: ×–×• ×”×ª××•× ×” ×”×¨××©×•× ×” ×‘×©×™×—×”.`;
                }
                
                // Prepare location context
                let locationText = '';
                if (currentLocation) {
                    if (placeName) {
                        // We have both GPS and place name from OpenStreetMap
                        locationText = `\n\nğŸ¯ ××™×§×•× ××“×•×™×§ ×-OpenStreetMap: "${placeName}"
×§×•××•×¨×“×™× ×˜×•×ª GPS: ${currentLocation.latitude}, ${currentLocation.longitude}

âš ï¸ **×›×œ×œ ×‘×¨×–×œ - ××¡×•×¨ ×œ×”×¤×¨!**
×”××§×•× ×©×‘×• ××ª×” × ××¦× ×”×•×: "${placeName}"
- ×–×” ×”××™×§×•× ×”××“×•×™×§ ×-OpenStreetMap
- ××ª×” **×—×™×™×‘** ×œ×ª×ª ×”×¡×‘×¨ ×¢×œ ××§×•× ×–×” ××• ×‘××–×•×¨ ×”×–×”
- **××¡×•×¨ ×‘×”×—×œ×˜** ×œ× ×—×© ××§×“×©/××ª×¨ ××—×¨ ×¨×—×•×§
- ×× ××ª×” ×œ× ×‘×˜×•×— ××” ×”××§×•× ×”××“×•×™×§ - ×ª×’×™×“ "×–×” ×‘××–×•×¨ ${placeName}" ×•×ª×ª××¨ ××” ××ª×” ×¨×•××” ×‘×ª××•× ×”
- ××œ ×ª××¦×™× ×©××•×ª ×©×œ ××§×•××•×ª ××—×¨×™×!

×”×ª××•× ×” ×¢×•×–×¨×ª ×¨×§ ×œ×–×”×•×ª ××” **×¡×¤×¦×™×¤×™×ª** ×‘×ª×•×š ×”××–×•×¨ ×”×–×”.`;
                    } else {
                        // Only GPS coordinates, no place name
                        locationText = `\n\nğŸ¯ ×§×•××•×¨×“×™× ×˜×•×ª GPS ××“×•×™×§×•×ª: ${currentLocation.latitude}, ${currentLocation.longitude}

âš ï¸ ×—×•×‘×” ×—×©×•×‘×”: ×”×§×•××•×¨×“×™× ×˜×•×ª ×”×œ×œ×• ×”×Ÿ ×”×¡××›×•×ª ×”×’×‘×•×”×” ×‘×™×•×ª×¨ ×œ××™×§×•×!
- ×—×¤×© ××” × ××¦× ×‘×“×™×•×§ ×‘×§×•××•×¨×“×™× ×˜×•×ª ×”××œ×”
- ××œ ×ª× ×—×© ××™×§×•× ×¨×—×•×§ ××• ×©×•× ×” ×œ×’××¨×™
- ×”×ª××•× ×” ××©××©×ª ×¨×§ ×œ×–×™×”×•×™ ××” ×¡×¤×¦×™×¤×™×ª ×‘×ª×•×š ×”××ª×—×
- ×× ×”×ª××•× ×” × ×¨××™×ª ×›××• ××§×•× X ××‘×œ ×”×§×•××•×¨×“×™× ×˜×•×ª ××¤× ×•×ª ×œ××§×•× Y - ×”××™×§×•× ×”×•× Y!`;
                    }
                } else {
                    locationText = `\n\n××™×Ÿ ×§×•××•×¨×“×™× ×˜×•×ª GPS ×–××™× ×•×ª. ×”×ª×‘×¡×¡ ×¢×œ × ×™×ª×•×— ×”×ª××•× ×” ×‘×œ×‘×“.`;
                }

                // Build the prompt with complex detection
                const prompt = `××ª×” ××“×¨×™×š ×˜×™×•×œ×™× ××•××—×” ×¢× ×”×ª××—×•×ª ×‘×™×¤×Ÿ.

×”××©×ª××© ×¦×™×œ× ××ª ×”×ª××•× ×” ×”××¦×•×¨×¤×ª.

×ª×—×•××™ ×”×¢× ×™×™×Ÿ ×©×œ ×”××©×ª××© (×‘×™×¤×Ÿ):
- ×”×™×¡×˜×•×¨×™×”
- ×ª×¨×‘×•×ª ×•×“×ª (×‘×•×“×”×™×–× ×•×©×™× ×˜×•)
- ×˜×‘×¢ ×•×”×œ×™×›×•×ª
- ××•×›×œ ×™×¤× ×™
- ××“×¨×™×›×œ×•×ª ××¡×•×¨×ª×™×ª
- ×’× ×™× ×™×¤× ×™×™×
- ××œ××›×” ×•××× ×•×ª (×§×¨××™×§×”, ×§×œ×™×’×¨×¤×™×”)
- ×”×™×¡×˜×•×¨×™×” ×¦×‘××™×ª (×¡××•×¨××™×, ×˜×™×¨×•×ª)
- ××¢×™×™× ×•×ª ×—××™× (Onsen)
- ×¤×¡×˜×™×‘×œ×™× ××§×•××™×™×
- ×—×™×™ ×¨×—×•×‘ ×¢×›×©×•×•×™×™×
- ×× ×™××” ×•×× ×’×”
${locationText}
${complexContext}

×”××©×™××” ×©×œ×š:
1. **×§×•×“× ×›×œ - ×–×”×” ××ª×—× ×œ×¤×™ GPS:**
   - ×× ×™×© ×§×•××•×¨×“×™× ×˜×•×ª GPS + ×©× ××§×•× ×-OpenStreetMap: **×–×” ×”××™×§×•×! ××¡×•×¨ ×œ×©× ×•×ª!**
   - ×× ×™×© ×¨×§ ×§×•××•×¨×“×™× ×˜×•×ª ×‘×œ×™ ×©×: ×—×¤×© ××” × ××¦× **×‘×“×™×•×§** ×‘××™×§×•× ×”×–×”
   - **××¡×•×¨ ×‘×”×—×œ×˜** ×œ× ×—×© ××§×“×©/××ª×¨ ××—×¨ ×©× ××¦× ×¨×—×•×§ ××”×§×•××•×¨×“×™× ×˜×•×ª
   - ×× ×œ× ×‘×˜×•×— - ×ª×’×™×“ "×–×” ×‘××–×•×¨ X" ×•×ª×ª××¨ ××” ×‘×ª××•× ×”
   - ×”×ª××•× ×” ××©××©×ª ×¨×§ ×œ×–×™×”×•×™ ××” ×¡×¤×¦×™×¤×™×ª × ××¦× ×‘××ª×—× - ×œ× ×œ× ×—×© ××ª ×”××ª×—×!
   - ×× ××™×Ÿ GPS: ×”×ª×‘×¡×¡ ×¢×œ × ×™×ª×•×— ×”×ª××•× ×” ×‘×œ×‘×“
   - ×× ×œ× × ×™×ª×Ÿ ×œ×–×”×•×ª ××ª×—× ×¡×¤×¦×™×¤×™: "×œ× ××–×•×”×”"
   - ×× ×”×§×•××•×¨×“×™× ×˜×•×ª ××—×•×¥ ×œ×™×¤×Ÿ (×§×• ×¨×•×—×‘ ×œ× 24-46, ×§×• ××•×¨×š ×œ× 122-154): ×¦×™×™×Ÿ ×©×–×” ×œ× ×‘×™×¤×Ÿ

2. **×”×©×•×•×” ×œ××ª×—× ×§×•×“×** (×× ×”×™×”):
   - ×”×× ×–×” ××•×ª×• ××ª×—× ×›××• ×”×ª××•× ×” ×”×§×•×“××ª?
   - ×ª×©×•×‘×”: ×›×Ÿ/×œ×

3. **×ª×Ÿ ×”×¡×‘×¨:**
   - ×× ×–×” ××•×ª×• ××ª×—×: ×“×œ×’ ×¢×œ ×¨×§×¢ ×›×œ×œ×™, ×”×ª××§×“ ×‘×¤×¨×˜ ×”×¡×¤×¦×™×¤×™ ×‘×ª××•× ×”
   - ×× ×–×” ××ª×—× ×—×“×© ××• ×œ× ××–×•×”×”: ×ª×Ÿ ×”×¡×‘×¨ ××œ× ×¢× ×¨×§×¢ ×•×”×§×©×¨
   - ×× ×”×›×ª×•×‘×ª ×™×¤× ×™×ª - ×ª×¨×’× ×•×ª×¡×‘×™×¨
   - ×›×œ×•×œ ×¤×¨×˜×™× ××¨×ª×§×™×, ×¡×™×¤×•×¨×™×, ×¢×•×‘×“×•×ª ×”×™×¡×˜×•×¨×™×•×ª, ×•×˜×™×¤×™× ××¢×©×™×™×
   - ×›×ª×•×‘ ×‘×¢×‘×¨×™×ª ×‘×¨×•×¨×” ×•××¨×ª×§×ª

**×¤×•×¨××˜ ×—×•×‘×” ×‘×ª×—×™×œ×ª ×”×ª×©×•×‘×”:**
[COMPLEX: ×©× ×”××ª×—× ×”×¡×¤×¦×™×¤×™ ××• "×œ× ××–×•×”×”"]
[SAME_AS_PREVIOUS: ×›×Ÿ/×œ×/×œ× ×¨×œ×•×•× ×˜×™]

×•××–:
×›×•×ª×¨×ª: [×©× ×”×¤×¨×™×˜/××§×•× ×”×¡×¤×¦×™×¤×™ ×‘×ª××•× ×”]

[×”×”×¡×‘×¨ - ×‘×˜×§×¡×˜ ×¨×’×™×œ ×‘×œ×‘×“, ×œ×œ× ×¡×™×× ×™ Markdown ×›××• ## ××• ** ××• *]

×—×©×•×‘: ×›×ª×•×‘ ×‘×˜×§×¡×˜ ×¨×’×™×œ ×‘×œ×‘×“ ×œ×œ× ×¡×™×× ×™ Markdown. ×”×˜×§×¡×˜ ×™×•×§×¨× ×‘×§×•×œ.`;

                // Convert image to base64
                const base64Image = currentImageData.split(',')[1];

                // Call Claude API directly
                const response = await fetch('https://api.anthropic.com/v1/messages', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'x-api-key': apiKey,
                        'anthropic-version': '2023-06-01',
                        'anthropic-dangerous-direct-browser-access': 'true'
                    },
                    body: JSON.stringify({
                        model: 'claude-sonnet-4-20250514',
                        max_tokens: 4096,
                        messages: [{
                            role: 'user',
                            content: [
                                {
                                    type: 'image',
                                    source: {
                                        type: 'base64',
                                        media_type: 'image/jpeg',
                                        data: base64Image
                                    }
                                },
                                {
                                    type: 'text',
                                    text: prompt
                                }
                            ]
                        }]
                    })
                });

                if (!response.ok) {
                    const errorData = await response.json().catch(() => ({}));
                    const errorMsg = errorData.error?.message || errorData.error || response.statusText;
                    throw new Error(`${response.status} - ${errorMsg}`);
                }

                const data = await response.json();
                const resultText = data.content[0].text;

                // Final step
                updateProgress(95, 4, '××¡×™×™×...');

                // Extract complex information from Claude's response
                const complexMatch = resultText.match(/\[COMPLEX:\s*(.+?)\]/);
                const sameMatch = resultText.match(/\[SAME_AS_PREVIOUS:\s*(.+?)\]/);
                
                const detectedComplex = complexMatch ? complexMatch[1].trim() : null;
                const isSameComplex = sameMatch && sameMatch[1].trim() === '×›×Ÿ';
                
                console.log('ğŸ“ Complex detection:', {
                    detected: detectedComplex,
                    previous: previousComplex,
                    same: isSameComplex
                });

                // Parse title and content (skip metadata lines)
                const lines = resultText.split('\n');
                let title = '×ª×•×¦××•×ª';
                let content = resultText;
                
                // Skip metadata lines and find title
                let contentStart = 0;
                for (let i = 0; i < lines.length; i++) {
                    const line = lines[i].trim();
                    
                    // Skip metadata lines
                    if (line.startsWith('[') && line.endsWith(']')) {
                        contentStart = i + 1;
                        continue;
                    }
                    
                    // Found title line
                    if (line.startsWith('×›×•×ª×¨×ª:')) {
                        title = line.replace('×›×•×ª×¨×ª:', '').trim();
                        content = lines.slice(i + 1).join('\n').trim();
                        break;
                    }
                    
                    // First real content line becomes title
                    if (line.length > 0 && line.length < 100 && !line.includes('.')) {
                        title = line;
                        content = lines.slice(i + 1).join('\n').trim();
                        break;
                    }
                }

                // Update complex tracking
                if (detectedComplex && detectedComplex !== '×œ× ××–×•×”×”') {
                    previousComplex = detectedComplex;
                    console.log(`âœ… Updated complex: "${detectedComplex}"`);
                } else {
                    previousComplex = null;
                    console.log('âŒ Complex not identified, cleared tracking');
                }
                
                // Add to history for statistics
                analysisHistory.push({
                    title,
                    complex: detectedComplex,
                    timestamp: new Date(),
                    location: currentLocation
                });

                // Update stats
                incrementAnalysisCount();

                // Complete progress
                updateProgress(100, 4, '×¡×™×™×!');
                setTimeout(() => {
                    stopProgressSimulation();
                    // Show results
                    showResults({ title, content });
                }, 500);

            } catch (error) {
                console.error('Error:', error);
                let errorMsg = '×©×’×™××” ×‘× ×™×ª×•×— ×”×ª××•× ×”:\n\n';
                
                if (error.message.includes('401') || error.message.includes('Unauthorized')) {
                    errorMsg += 'âŒ ××¤×ª×— ×”-API ×©×’×•×™ ××• ×œ× ×ª×§×£\n\n×¤×ª×¨×•×Ÿ:\n1. ×œ×š ×œ×”×’×“×¨×•×ª\n2. ×œ×—×¥ ×¢×œ ğŸ‘ï¸ ×•×‘×“×•×§ ×©×”××¤×ª×— ××ª×—×™×œ ×‘-sk-ant-\n3. ×¦×•×¨ ××¤×ª×— ×—×“×© ×‘-console.anthropic.com';
                } else if (error.message.includes('429') || error.message.includes('rate limit')) {
                    errorMsg += 'â³ ×¢×‘×¨×ª ××ª ××’×‘×œ×ª ×”×§×¦×‘\n\n×”××ª×Ÿ ×›××” ×“×§×•×ª ×•× ×¡×” ×©×•×‘.';
                } else if (error.message.includes('402') || error.message.includes('insufficient')) {
                    errorMsg += 'ğŸ’° ××™×Ÿ ××¡×¤×™×§ ×§×¨×“×™×˜ ×‘×—×©×‘×•×Ÿ!\n\n×¤×ª×¨×•×Ÿ:\n1. ×›× ×¡ ×œ-console.anthropic.com\n2. ×œ×š ×œ-Billing\n3. ×˜×¢×Ÿ $20-30';
                } else if (error.message.includes('404')) {
                    errorMsg += 'âŒ ×”××¤×ª×— ×œ× × ××¦× ××• × ××—×§\n\n×¤×ª×¨×•×Ÿ:\n1. ×›× ×¡ ×œ-console.anthropic.com\n2. ×¦×•×¨ ××¤×ª×— ×—×“×©\n3. ×”×¢×ª×§ ×•×”×“×‘×§ ×‘×”×’×“×¨×•×ª';
                } else if (!navigator.onLine) {
                    errorMsg += 'ğŸ“¡ ××™×Ÿ ×—×™×‘×•×¨ ×œ××™× ×˜×¨× ×˜!\n\n×‘×“×•×§ ××ª ×”×—×™×‘×•×¨ ×•× ×¡×” ×©×•×‘.';
                } else if (error.message.includes('image exceeds')) {
                    errorMsg += 'ğŸ“· ×”×ª××•× ×” ×’×“×•×œ×” ××“×™!\n\n×”×ª××•× ×” × ×“×—×¡×” ××‘×œ ×¢×“×™×™×Ÿ ×’×“×•×œ×”.\n× ×¡×” ×œ×¦×œ× ×ª××•× ×” ×‘×¨×–×•×œ×•×¦×™×” × ××•×›×” ×™×•×ª×¨.';
                } else {
                    errorMsg += error.message + '\n\nğŸ’¡ ×˜×™×¤×™×:\n1. ×‘×“×•×§ ×©×”××¤×ª×— × ×›×•×Ÿ ×‘×”×’×“×¨×•×ª\n2. ×•×•×“× ×©×™×© ×§×¨×“×™×˜ ×‘×—×©×‘×•×Ÿ\n3. ×‘×“×•×§ ××ª ×”×—×™×‘×•×¨ ×œ××™× ×˜×¨× ×˜';
                }
                
                alert(errorMsg);
            } finally {
                stopProgressSimulation();
                document.getElementById('loading').classList.remove('active');
            }
        }

        function showResults(response) {
            document.getElementById('resultTitle').textContent = response.title || '×ª×•×¦××•×ª';
            document.getElementById('resultContent').textContent = response.content;
            document.getElementById('resultSection').classList.add('active');
            currentResult = response;
        }

        // Text-to-speech with markdown cleanup
        // Text-to-speech with markdown cleanup and wake lock
        async function readAloud() {
            if (!currentResult) return;
            
            stopReading();
            
            // Request wake lock to keep screen on
            try {
                if ('wakeLock' in navigator) {
                    wakeLock = await navigator.wakeLock.request('screen');
                    console.log('Wake Lock active - ×”××¡×š ×™×©××¨ ×“×œ×•×§');
                    
                    // Release wake lock when speech ends
                    wakeLock.addEventListener('release', () => {
                        console.log('Wake Lock released');
                    });
                }
            } catch (err) {
                console.log('Wake Lock ×œ× ×–××™×Ÿ:', err.message);
            }
            
            // Combine title and content
            let fullText = currentResult.title + '. ' + currentResult.content;
            
            // Clean markdown and special characters
            fullText = cleanTextForSpeech(fullText);
            
            currentUtterance = new SpeechSynthesisUtterance(fullText);
            currentUtterance.lang = 'he-IL';
            currentUtterance.rate = 0.9; // Slightly faster for better flow
            currentUtterance.pitch = 1.05; // Slightly higher pitch for clarity
            
            // Try to find the best Hebrew voice
            const voices = speechSynthesis.getVoices();
            console.log('Available voices:', voices.map(v => `${v.name} (${v.lang})`));
            
            // Look for Hebrew voices in order of preference
            const hebrewVoice = 
                voices.find(v => v.lang === 'he-IL' && v.name.includes('Premium')) || // Premium first
                voices.find(v => v.lang === 'he-IL' && !v.name.includes('eSpeak')) || // Non-eSpeak
                voices.find(v => v.lang.startsWith('he')) || // Any Hebrew
                voices.find(v => v.lang === 'en-US' && v.name.includes('Google')); // Fallback to good English
            
            if (hebrewVoice) {
                currentUtterance.voice = hebrewVoice;
                console.log('Using voice:', hebrewVoice.name);
            } else {
                console.log('No Hebrew voice found, using default');
            }
            
            // Release wake lock when speech ends
            currentUtterance.onend = function() {
                releaseWakeLock();
            };
            
            currentUtterance.onerror = function() {
                releaseWakeLock();
            };
            
            speechSynthesis.speak(currentUtterance);
        }
        
        // Release wake lock
        function releaseWakeLock() {
            if (wakeLock) {
                wakeLock.release().then(() => {
                    console.log('Wake Lock released - ×”××¡×š ×™×›×•×œ ×œ×›×‘×•×ª');
                    wakeLock = null;
                });
            }
        }

        function stopReading() {
            if (speechSynthesis.speaking) {
                speechSynthesis.cancel();
            }
            releaseWakeLock();
        }

        // Clean text for speech - remove markdown and special characters
        function cleanTextForSpeech(text) {
            return text
                // Remove markdown headers (##, ###, etc.)
                .replace(/^#{1,6}\s+/gm, '')
                // Remove bold/italic markers
                .replace(/\*\*(.+?)\*\*/g, '$1')
                .replace(/\*(.+?)\*/g, '$1')
                .replace(/__(.+?)__/g, '$1')
                .replace(/_(.+?)_/g, '$1')
                // Remove emojis (optional - they sound weird)
                .replace(/[\u{1F300}-\u{1F9FF}]/gu, '')
                // Remove special markdown symbols
                .replace(/[â›©ï¸ğŸ¯ğŸ“ğŸ¦ŠğŸ¥¾ğŸ’¡ğŸŒ]/g, '')
                // Remove bullet points and list markers
                .replace(/^[â€¢\-\*]\s+/gm, '')
                // Remove multiple spaces
                .replace(/\s+/g, ' ')
                // Trim
                .trim();
        }

        // Copy text to clipboard
        async function copyText() {
            if (!currentResult) return;
            
            const fullText = currentResult.title + '\n\n' + currentResult.content;
            
            try {
                // Modern API
                await navigator.clipboard.writeText(fullText);
                alert('âœ… ×”×˜×§×¡×˜ ×”×•×¢×ª×§ ×œ×œ×•×—!\n\n×¢×›×©×™×• ×ª×•×›×œ ×œ×”×“×‘×™×§ ××•×ª×• ×‘××¤×œ×™×§×¦×™×™×ª ×”×§×¨××”.');
            } catch (err) {
                // Fallback for older browsers
                const textArea = document.createElement('textarea');
                textArea.value = fullText;
                textArea.style.position = 'fixed';
                textArea.style.left = '-9999px';
                document.body.appendChild(textArea);
                textArea.select();
                
                try {
                    document.execCommand('copy');
                    alert('âœ… ×”×˜×§×¡×˜ ×”×•×¢×ª×§ ×œ×œ×•×—!\n\n×¢×›×©×™×• ×ª×•×›×œ ×œ×”×“×‘×™×§ ××•×ª×• ×‘××¤×œ×™×§×¦×™×™×ª ×”×§×¨××”.');
                } catch (err) {
                    alert('âŒ ×œ× ×”×¦×œ×—×ª×™ ×œ×”×¢×ª×™×§.\n\n× ×¡×” ×œ×‘×—×•×¨ ××ª ×”×˜×§×¡×˜ ×™×“× ×™×ª (×œ×—×™×¦×” ××¨×•×›×”) ×•×œ×”×¢×ª×™×§.');
                }
                
                document.body.removeChild(textArea);
            }
        }

        // Download text as TXT file
        function downloadText() {
            if (!currentResult) return;
            
            const fullText = currentResult.title + '\n\n' + currentResult.content;
            
            // Create blob
            const blob = new Blob([fullText], { type: 'text/plain;charset=utf-8' });
            const url = URL.createObjectURL(blob);
            
            // Create download link
            const a = document.createElement('a');
            a.href = url;
            
            // Generate filename from title
            const filename = currentResult.title.replace(/[^×-×ªa-zA-Z0-9\s]/g, '').substring(0, 50) || '×”×¡×‘×¨';
            a.download = filename + '.txt';
            
            // Trigger download
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            
            // Clean up
            URL.revokeObjectURL(url);
            
            // Show instructions
            setTimeout(() => {
                alert('âœ… ×”×§×•×‘×¥ ×”×•×¨×“ ×‘×”×¦×œ×—×”!\n\nğŸ“± ×›×¢×ª:\n1. ×¤×ª×— ××ª @Voice Aloud Reader\n2. ×œ×—×¥ ×¢×œ "+" ××• "Add files"\n3. ×‘×—×¨ ××ª ×”×§×•×‘×¥ ×©×”×•×¨×“×ª\n4. ×œ×—×¥ Play! ğŸ§');
            }, 500);
        }

        // Make sure voices are loaded
        if (speechSynthesis.onvoiceschanged !== undefined) {
            speechSynthesis.onvoiceschanged = () => {};
        }

        // Save to history
        async function saveToHistory() {
            if (!currentResult || !currentImageData) {
                alert('××™×Ÿ ×ª×•×¦××” ×œ×©××™×¨×”!');
                return;
            }
            
            try {
                const history = JSON.parse(localStorage.getItem('japanGuideHistory') || '[]');
                
                // Create thumbnail (150x150 for better quality in history)
                console.log('Creating thumbnail...');
                const thumbnail = await createThumbnail(currentImageData, 150, 150);
                console.log('âœ… Thumbnail created');
                
                const entryId = Date.now();
                const entry = {
                    id: entryId,
                    date: (currentPhotoDate || new Date()).toISOString(),
                    title: currentResult.title,
                    content: currentResult.content,
                    thumbnail: thumbnail, // Save small thumbnail to localStorage
                    location: currentLocation ? `×§×• ×¨×•×—×‘: ${currentLocation.latitude.toFixed(6)}, ×§×• ××•×¨×š: ${currentLocation.longitude.toFixed(6)}` : null,
                    complex: previousComplex,
                    hasFullImage: false // Will be updated if IndexedDB succeeds
                };
                
                // Try to save full image to IndexedDB (in parallel, non-blocking)
                saveImageToIndexedDB(entryId, currentImageData, {
                    title: currentResult.title,
                    date: entry.date,
                    location: entry.location,
                    complex: previousComplex
                }).then(success => {
                    if (success) {
                        console.log('âœ… Full image saved to IndexedDB');
                        // Update the entry to indicate full image is available
                        const updatedHistory = JSON.parse(localStorage.getItem('japanGuideHistory') || '[]');
                        const entryIndex = updatedHistory.findIndex(e => e.id === entryId);
                        if (entryIndex !== -1) {
                            updatedHistory[entryIndex].hasFullImage = true;
                            localStorage.setItem('japanGuideHistory', JSON.stringify(updatedHistory));
                        }
                        
                        // Cleanup old images periodically
                        cleanupOldImages();
                    } else {
                        console.warn('âš ï¸ Could not save full image to IndexedDB, only thumbnail saved');
                    }
                }).catch(err => {
                    console.warn('IndexedDB save failed:', err);
                });
                
                history.unshift(entry);
                
                // Keep only last 50 entries
                if (history.length > 50) {
                    history.length = 50;
                }
                
                localStorage.setItem('japanGuideHistory', JSON.stringify(history));
                
                console.log('âœ… Saved to history with thumbnail');
                alert('âœ… × ×©××¨ ×œ×”×™×¡×˜×•×¨×™×”!\n\nğŸ’¡ Thumbnail × ×©××¨ ×œ×¦×¤×™×™×” ××”×™×¨×”.\nğŸ“¦ ×ª××•× ×” ××œ××” × ×©××¨×ª ×œ×™×¦×•× ×™×•××Ÿ ××¡×¢.');
                
            } catch (e) {
                console.error('Error saving to history:', e);
                
                if (e.name === 'QuotaExceededError') {
                    alert('âŒ ××™×Ÿ ××¡×¤×™×§ ××§×•× ×œ×©××™×¨×”!\n\n× ×¡×” ×œ××—×•×§ ×”×™×¡×˜×•×¨×™×” ×™×©× ×” ×‘×”×’×“×¨×•×ª.');
                } else {
                    // Fallback: try saving without thumbnail
                    try {
                        const history = JSON.parse(localStorage.getItem('japanGuideHistory') || '[]');
                        const entry = {
                            id: Date.now(),
                            date: (currentPhotoDate || new Date()).toISOString(),
                            title: currentResult.title,
                            content: currentResult.content,
                            thumbnail: null, // No thumbnail
                            location: currentLocation ? `×§×• ×¨×•×—×‘: ${currentLocation.latitude.toFixed(6)}, ×§×• ××•×¨×š: ${currentLocation.longitude.toFixed(6)}` : null,
                            complex: previousComplex,
                            hasFullImage: false
                        };
                        history.unshift(entry);
                        if (history.length > 50) history.length = 50;
                        localStorage.setItem('japanGuideHistory', JSON.stringify(history));
                        alert('âœ… × ×©××¨ ×œ×”×™×¡×˜×•×¨×™×” (×œ×œ× ×ª××•× ×”)');
                    } catch (fallbackError) {
                        alert('âŒ ×©×’×™××” ×‘×©××™×¨×”: ' + e.message);
                    }
                }
            }
        }
        
        // Load history
        function loadHistory() {
            const history = JSON.parse(localStorage.getItem('japanGuideHistory') || '[]');
            const historyList = document.getElementById('historyList');
            
            if (history.length === 0) {
                historyList.innerHTML = '<p style="text-align: center; color: #999; padding: 40px;">×¢×“×™×™×Ÿ ××™×Ÿ ×”×™×¡×˜×•×¨×™×”. ×¦× ×œ×˜×™×™×œ ×•×¦×œ×!</p>';
                return;
            }
            
            historyList.innerHTML = history.map((entry, index) => {
                // Support both old format (image) and new format (thumbnail)
                const imageData = entry.thumbnail || entry.image;
                
                const imageHtml = imageData 
                    ? `<img src="${imageData}" alt="${entry.title}" style="width: 100%; height: 150px; object-fit: cover;">` 
                    : `<div style="width: 100%; height: 150px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); display: flex; align-items: center; justify-content: center; color: white; font-size: 3rem;">ğŸ“¸</div>`;
                
                const locationBadge = entry.location 
                    ? `<div style="font-size: 0.75rem; color: #666; margin-top: 5px;">ğŸ“ ${entry.location}</div>`
                    : '';
                
                const complexBadge = entry.complex && entry.complex !== '×œ× ××–×•×”×”'
                    ? `<div style="font-size: 0.75rem; background: #e8f5e9; color: #2e7d32; padding: 3px 8px; border-radius: 4px; display: inline-block; margin-top: 5px;">ğŸ¯ ${entry.complex}</div>`
                    : '';
                
                return `
                    <div class="history-item" style="position: relative;">
                        <button onclick="deleteHistoryItem(${index}, event)" style="position: absolute; top: 8px; right: 8px; background: rgba(255,0,0,0.8); color: white; border: none; border-radius: 50%; width: 32px; height: 32px; font-size: 18px; cursor: pointer; z-index: 10; display: flex; align-items: center; justify-content: center; box-shadow: 0 2px 4px rgba(0,0,0,0.3);" title="××—×§">âŒ</button>
                        <div onclick='viewHistoryItem(${index})' style="cursor: pointer;">
                            ${imageHtml}
                            <div class="history-date">${new Date(entry.date).toLocaleDateString('he-IL', {
                                year: 'numeric',
                                month: 'long',
                                day: 'numeric',
                                hour: '2-digit',
                                minute: '2-digit'
                            })}</div>
                            <div class="history-title">${entry.title}</div>
                            ${complexBadge}
                            ${locationBadge}
                            <div class="history-preview">${entry.content.substring(0, 100)}...</div>
                        </div>
                    </div>
                `;
            }).join('');
        }
        
        // Delete single history item
        async function deleteHistoryItem(index, event) {
            event.stopPropagation(); // Prevent opening the item
            
            const history = JSON.parse(localStorage.getItem('japanGuideHistory') || '[]');
            
            if (index < 0 || index >= history.length) {
                alert('âŒ ×©×’×™××”: ×¤×¨×™×˜ ×œ× × ××¦×');
                return;
            }
            
            const entry = history[index];
            
            // Confirm deletion
            if (!confirm(`ğŸ—‘ï¸ ×œ××—×•×§ ××ª "${entry.title}"?\n\n×¤×¢×•×œ×” ×–×• ×ª××—×§ ×’× ××ª ×”×ª××•× ×” ×”××œ××” ××”×–×™×›×¨×•×Ÿ.`)) {
                return;
            }
            
            try {
                // Delete from IndexedDB if exists
                if (entry.id && db) {
                    try {
                        const transaction = db.transaction([STORE_NAME], 'readwrite');
                        const objectStore = transaction.objectStore(STORE_NAME);
                        objectStore.delete(entry.id);
                        console.log('âœ… Deleted image from IndexedDB:', entry.id);
                    } catch (err) {
                        console.warn('Could not delete from IndexedDB:', err);
                    }
                }
                
                // Delete from localStorage
                history.splice(index, 1);
                localStorage.setItem('japanGuideHistory', JSON.stringify(history));
                
                console.log('âœ… Deleted from history');
                
                // Reload history display
                loadHistory();
                
                alert('âœ… × ××—×§ ×‘×”×¦×œ×—×”!');
                
            } catch (error) {
                console.error('Error deleting item:', error);
                alert('âŒ ×©×’×™××” ×‘××—×™×§×”: ' + error.message);
            }
        }

        function viewHistoryItem(index) {
            const history = JSON.parse(localStorage.getItem('japanGuideHistory') || '[]');
            const entry = history[index];
            
            currentResult = entry;
            
            // Support both old format (image) and new format (thumbnail)
            const imageData = entry.thumbnail || entry.image;
            currentImageData = imageData;
            
            document.getElementById('previewImage').src = entry.image;
            document.getElementById('previewContainer').style.display = 'block';
            
            if (entry.location) {
                document.getElementById('locationInfo').style.display = 'block';
                document.getElementById('coordinates').textContent = entry.location;
                document.getElementById('noLocationWarning').style.display = 'none';
            }
            
            document.getElementById('resultTitle').textContent = entry.title;
            document.getElementById('resultContent').textContent = entry.content;
            document.getElementById('resultSection').classList.add('active');
            
            // Switch to camera tab
            document.querySelectorAll('.tab').forEach(tab => tab.classList.remove('active'));
            document.querySelectorAll('.tab')[0].classList.add('active');
            document.querySelectorAll('.tab-content').forEach(content => content.classList.add('hidden'));
            document.getElementById('cameraTab').classList.remove('hidden');
            
            // Scroll to top
            window.scrollTo(0, 0);
        }

        // Export diary
        function exportDiary() {
            const history = JSON.parse(localStorage.getItem('japanGuideHistory') || '[]');
            
            if (history.length === 0) {
                alert('××™×Ÿ ×¤×¨×™×˜×™× ×œ×™×™×¦×•×!');
                return;
            }
            
            // Create simple text export
            let diaryText = 'ğŸ““ ×™×•××Ÿ ×”×˜×™×•×œ ×©×œ×™ ×‘×™×¤×Ÿ\n';
            diaryText += `× ×•×¦×¨: ${new Date().toLocaleDateString('he-IL')}\n`;
            diaryText += `×¡×”"×› ××§×•××•×ª: ${history.length}\n\n`;
            diaryText += '='.repeat(60) + '\n\n';
            
            history.forEach((entry, index) => {
                diaryText += `\n${index + 1}. ${entry.title}\n`;
                diaryText += `${'â”€'.repeat(60)}\n`;
                diaryText += `ğŸ“… ${new Date(entry.date).toLocaleDateString('he-IL', { 
                    year: 'numeric', 
                    month: 'long', 
                    day: 'numeric',
                    hour: '2-digit',
                    minute: '2-digit'
                })}\n`;
                if (entry.location) {
                    diaryText += `ğŸ“ ${entry.location}\n`;
                }
                diaryText += `\n${entry.content}\n\n`;
                diaryText += '='.repeat(60) + '\n';
            });
            
            // Download as text file
            const blob = new Blob([diaryText], { type: 'text/plain;charset=utf-8' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = '×™×•××Ÿ_×˜×™×•×œ_×™×¤×Ÿ_' + new Date().toISOString().split('T')[0] + '.txt';
            a.click();
            URL.revokeObjectURL(url);
            
            alert('âœ… ×”×™×•××Ÿ ×™×•×¦× ×‘×”×¦×œ×—×”!');
        }

        // Settings functions
        function toggleApiKeyVisibility() {
            const apiKeyInput = document.getElementById('apiKey');
            if (apiKeyInput.type === 'password') {
                apiKeyInput.type = 'text';
            } else {
                apiKeyInput.type = 'password';
            }
        }

        function saveApiKey() {
            const apiKey = document.getElementById('apiKey').value.trim();
            const statusEl = document.getElementById('apiKeyStatus');
            
            if (!apiKey) {
                statusEl.textContent = 'âŒ × × ×œ×”×–×™×Ÿ ××¤×ª×— API!';
                statusEl.style.color = 'red';
                return;
            }
            
            // Validate API key format
            if (!apiKey.startsWith('sk-ant-')) {
                statusEl.textContent = 'âš ï¸ ×”××¤×ª×— ×œ× × ×¨××” ×ª×§×™×Ÿ - ×¦×¨×™×š ×œ×”×ª×—×™×œ ×‘-sk-ant-';
                statusEl.style.color = 'orange';
                return;
            }
            
            if (apiKey.length < 50) {
                statusEl.textContent = 'âš ï¸ ×”××¤×ª×— × ×¨××” ×§×¦×¨ ××“×™ - ×•×•×“× ×©×”×¢×ª×§×ª ××•×ª×• ×‘××œ×•××•';
                statusEl.style.color = 'orange';
                return;
            }
            
            localStorage.setItem('claudeApiKey', apiKey);
            statusEl.textContent = 'âœ… ××¤×ª×— API × ×©××¨ ×‘×”×¦×œ×—×”!';
            statusEl.style.color = 'green';
            
            setTimeout(() => {
                statusEl.textContent = '';
            }, 3000);
        }

        function loadApiKey() {
            const apiKey = localStorage.getItem('claudeApiKey');
            if (apiKey) {
                document.getElementById('apiKey').value = apiKey;
            }
        }

        function updateStats() {
            const history = JSON.parse(localStorage.getItem('japanGuideHistory') || '[]');
            const analysisCount = parseInt(localStorage.getItem('analysisCount') || '0');
            
            document.getElementById('statsImages').textContent = analysisCount;
            document.getElementById('statsHistory').textContent = history.length;
            
            // Rough cost estimation
            const estimatedCost = (analysisCount * 0.003).toFixed(2);
            document.getElementById('statsEstimatedCost').textContent = estimatedCost;
        }

        function incrementAnalysisCount() {
            const count = parseInt(localStorage.getItem('analysisCount') || '0');
            localStorage.setItem('analysisCount', (count + 1).toString());
        }

        function clearHistory() {
            if (!confirm('×”×× ××ª×” ×‘×˜×•×— ×©×‘×¨×¦×•× ×š ×œ××—×•×§ ××ª ×›×œ ×”×”×™×¡×˜×•×¨×™×”? ×¤×¢×•×œ×” ×–×• ×œ× × ×™×ª× ×ª ×œ×‘×™×˜×•×œ!')) {
                return;
            }
            
            localStorage.removeItem('japanGuideHistory');
            localStorage.setItem('analysisCount', '0');
            visitedPlaces.clear();
            
            loadHistory();
            updateStats();
            
            alert('âœ… ×”×”×™×¡×˜×•×¨×™×” × ××—×§×” ×‘×”×¦×œ×—×”!');
        }

        // Initialize
        document.addEventListener('DOMContentLoaded', function() {
            updateOnlineStatus();
            loadApiKey();
            updateStats();
        });
    </script>
</body>
</html>
